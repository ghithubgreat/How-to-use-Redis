# Redis与MySQL库存同步机制设计方案

## 问题背景

在高并发环境下，系统使用Redis作为商品库存的缓存，同时在MySQL中保存真实的库存数据。但由于以下原因可能导致Redis与MySQL中的库存数据不一致：

1. 系统崩溃或重启导致消息处理中断
2. 网络问题导致MQ消息丢失
3. Redis服务器故障或数据过期
4. 并发异常导致的数据不一致

## 同步机制设计

### 1. 定时任务同步

系统实现了一个定期执行的同步任务，用于检测和修复Redis与MySQL中的库存不一致问题：

```java
@Scheduled(fixedRate = 600000)  // 每10分钟执行一次
public void syncStockData() {
    stockSyncService.syncStockData();
}
```

### 2. 同步策略

同步过程采用以下策略：

1. **全量比对**：获取所有商品数据，逐一比较Redis与MySQL中的库存数值
2. **以MySQL为准**：发现不一致时，以MySQL数据库中的库存为准进行修正
3. **自动补全**：对于Redis中不存在但MySQL中存在的商品，自动将数据同步到Redis
4. **自动清理**：对于Redis中存在但MySQL中不存在的商品，从Redis中删除

### 3. 同步粒度

同步机制设计了多个维度的处理：

- **新增同步**：MySQL有但Redis没有的数据
- **更新同步**：MySQL与Redis数据不一致的情况
- **删除同步**：MySQL没有但Redis有的数据

### 4. 错误处理与日志

- 同步过程中的每一步都有详细日志记录
- 对于异常情况进行捕获并记录，确保单个商品的同步错误不影响整体同步过程
- 严重错误时发送告警（可扩展）

## 改进建议

### 1. 分布式锁机制

在多实例部署环境下，建议为同步任务增加分布式锁：

```java
@Scheduled(fixedRate = 600000)
public void syncStockData() {
    String lockKey = "stock:sync:lock";
    boolean locked = redisTemplate.opsForValue().setIfAbsent(lockKey, "1", 10, TimeUnit.MINUTES);
    if (locked) {
        try {
            stockSyncService.syncStockData();
        } finally {
            redisTemplate.delete(lockKey);
        }
    }
}
```

### 2. 增量同步机制

对于商品数量较多的场景，可以实现增量同步机制：

- 记录每个商品的最后修改时间
- 每次只同步自上次同步以来有变更的商品
- 可配置定期全量同步（如每天一次）和增量同步（如每小时一次）

### 3. 同步优先级设计

不同商品可以设置不同的同步优先级：

- 热门商品：高频次同步
- 常规商品：常规频次同步
- 低频商品：低频次同步

### 4. 监控告警系统

建议增加库存一致性监控：

- 记录同步成功率
- 记录不一致比例
- 设置阈值告警（如不一致商品超过5%触发告警）

### 5. 手动触发机制

系统已实现手动触发同步的接口：

```
POST /api/stock/sync
```

建议增加针对单个商品的同步接口：

```
POST /api/stock/sync/{productId}
```

### 6. 版本号机制

引入版本号机制避免ABA问题：

- 每次库存变更增加版本号
- 同步时比对版本号，确保数据变更的一致性
- 版本不一致时进行修复

## 结论

通过定时同步任务，系统能够自动检测和修复Redis与MySQL之间的库存不一致问题，提高数据一致性和系统可靠性。建议根据实际业务规模和并发情况，调整同步频率和实现更细粒度的同步策略。 