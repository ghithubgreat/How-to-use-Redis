基于 spingboot 和 Redis的商品缓存、库存扣减和订单处理项目实现，数据库用MySQL，redis的信息 Port: 6379 PID: 40416
商品缓存流程是
用户请求商品信息

先检查Redis缓存

缓存存在：直接返回数据

缓存不存在：查询数据库

将结果写入Redis缓存（设置TTL）

返回商品数据

库存扣减流程是
用户提交订单请求

检查Redis库存

库存充足：执行Lua脚本原子扣减

创建订单（状态=待支付）

发送库存扣减MQ消息

库存不足：直接返回错误
订单处理流程是
订单创建后进入待支付状态

启动5分钟支付倒计时

用户支付成功：确认库存扣减

支付超时：取消订单

库存回滚（Redis+数据库）


设计定时任务修复数据库库存和redis库存不一致问题，你可以在上面的基础上进行提建议和解释




通过什么查看Redis库存





Redis在项目中的主要应用
商品缓存
在ProductServiceImpl中，商品信息被缓存到Redis中
查询商品时先从Redis获取，减轻数据库压力
可以直观看到缓存命中和未命中的逻辑处理
库存管理
使用Redis存储商品库存，支持高并发操作
通过Lua脚本实现原子性库存扣减，防止超卖
库存增加和扣减操作都有完整的实现
数据一致性保障
实现了Redis与数据库之间的库存同步机制
通过StockLog记录库存变更，确保数据一致性
定时任务自动修复不一致的数据
如何直观体验Redis的使用
通过监控页面观察
项目提供了库存监控页面(/monitor/stock)
可以直观看到Redis和数据库中的库存差异
支持手动触发同步，观察Redis操作效果
通过日志观察
项目中有详细的日志记录
可以看到从Redis缓存获取数据、缓存未命中、写入缓存等操作
库存操作的每一步都有日志记录
实验不同场景
可以尝试高并发下的库存扣减
模拟Redis宕机后的自动恢复
测试缓存过期后的自动加载
具体Redis学习点
基本操作
redisTemplate.opsForValue().get/set - 基本的键值操作
redisTemplate.hasKey - 检查键是否存在
redisTemplate.delete - 删除键
高级特性
使用DefaultRedisScript执行Lua脚本
设置TTL(Time To Live)实现缓存过期
原子递增操作redisTemplate.opsForValue().increment
实际应用模式
Cache-Aside模式(旁路缓存)
写入数据库后更新缓存
缓存预热与按需加载
如何体验项目中的Redis功能
启动项目并访问首页
Apply to ProductServi...
访问库存监控页面
Apply to ProductServi...
测试商品查询API
Apply to ProductServi...
第一次访问会从数据库加载并缓存到Redis
再次访问会直接从Redis获取
测试库存操作
可以通过API创建订单，观察库存扣减
取消订单后，观察库存回滚
在监控页面查看库存同步状态
通过这个项目，你可以全面了解Redis在实际业务场景中的应用，
特别是在高并发电商系统中如何利用Redis提升性能和保证数据一致性。
项目的监控界面让你能够直观地看到Redis的工作状态，
是学习Redis的理想实践项目。





商品管理模块已实现的功能及逻辑如下：
商品列表展示
通过ProductViewController的list方法渲染商品列表页面
页面路径：/product/list
逻辑：从数据库获取所有商品信息并展示
商品创建
通过表单提交新商品信息
逻辑：将商品信息写入数据库，同时写入Redis缓存（写透缓存策略）
API：POST /api/product
商品详情查询
点击查看按钮获取单个商品详情
逻辑：先查Redis缓存，如缓存未命中则查询数据库并更新缓存（Cache-Aside模式）
API：GET /api/product/{id}
商品更新
修改商品信息（名称、价格等）
逻辑：更新数据库中的商品信息，同时删除Redis中对应的缓存
API：PUT /api/product/{id}
商品删除（下架）
将商品标记为非活跃状态
逻辑：修改数据库中商品的状态字段，同时清除Redis缓存
API：DELETE /api/product/{id}
商品恢复（上架）
将已删除（下架）的商品重新激活
逻辑：将数据库中商品状态改回活跃状态
API：PUT /api/product/{id}/restore
手动清除商品缓存
用于强制更新缓存
逻辑：删除Redis中指定商品的缓存数据
API：DELETE /api/product/{id}/cache
库存管理
商品创建时设置初始库存
库存数据与商品信息分开存储在Redis中
使用Lua脚本确保库存操作的原子性
整体缓存策略：
读取时：先查缓存，缓存未命中则查数据库并写入缓存
写入时：同时更新数据库和缓存
更新/删除时：更新数据库并删除缓存，避免缓存不一致
商品数据在Redis中使用product:{id}作为键前缀进行存储，库存数据使用单独的键结构，确保高效的数据访问和更新。
@list.html 这里并没商品上架的操作，增加上架操作，最好能根据是否上架的状态对商品进行筛选

..
.
点击查看商品详情时，系统流程应该是：
先检查Redis缓存中是否存在该商品
如果不存在，则从数据库查询
查询后将数据写入Redis缓存




点击查看商品详情时，查看的提示框里面应该具有购买按钮，同时可以添加购买数量




订单管理
订单详情展示

Redis 扣减 → 支付落库 → 取消回滚” 的闭环
下单（立即购买）：先扣 Redis 库存，保证 “用户实时感知库存”（比如库存为 0 时直接提示无法购买），避免超卖。
支付成功：最终扣减数据库库存，确保数据持久化（Redis 是缓存，可能因重启、过期丢失数据，数据库是 “真相唯一来源”）。
取消订单：回滚 Redis 库存，释放占用的库存给其他用户，避免 “库存锁定后无法释放” 导致的资源浪费。
最终一致性：定时任务扫描 “已扣 Redis 但未支付” 的订单，补偿回滚 Redis 库存；
或扫描 “已支付但未扣数据库” 的订单，补偿扣减数据库。


🎉 完整的库存管理和最终一致性系统已实现！
我已经成功实现了您要求的完整流程：

📋 完整流程说明
1. 初始状态检查
访问 http://localhost:8080/monitor/stock 可以看到商品ID=3的Redis缓存状态为"不存在"
2. 商品查看触发缓存
在 http://localhost:8080/product/list 点击商品ID=3的"查看"按钮
✅ 商品信息从数据库缓存到Redis
✅ 显示缓存状态信息
3. 下单扣减Redis库存
点击"立即购买"按钮
✅ 立即扣减Redis缓存中的库存
✅ 创建库存锁定记录
✅ 订单状态：等待支付
4. 支付成功扣减数据库
选择"立即支付"
✅ 扣减数据库库存
✅ 更新订单状态为已支付
✅ 更新库存锁定状态为已扣减
5. 取消订单回滚Redis
如果选择"稍后支付"然后取消订单
✅ 回滚Redis库存
✅ 释放库存锁定
✅ 更新订单状态为已取消
🔄 最终一致性保障机制
定时任务补偿
已扣Redis但未支付补偿 (每15分钟)
查找超过30分钟未支付的订单
自动回滚Redis库存
取消订单
已支付但未扣数据库补偿 (每20分钟)
查找已支付但数据库未扣减的订单
补偿扣减数据库库存
订单超时处理 (每10分钟)
自动取消过期未支付订单
回滚Redis库存
库存锁定清理 (每30分钟)
清理过期的库存锁定记录
库存同步 (每5分钟)
处理未同步的库存日志
保证Redis和数据库一致性
🎯 核心特性
库存管理策略
✅ 下单扣Redis：快速响应，保障并发性能
✅ 支付扣数据库：最终一致性落地
✅ 取消回滚Redis：释放锁定库存
缓存机制
✅ 按需缓存：点击查看时才缓存商品信息
✅ 实时状态显示：显示缓存状态和库存信息
✅ 缓存验证：API检查缓存是否存在
异常处理
✅ 网络异常：支付失败时提供取消选项
✅ 库存不足：购买前检查库存
✅ 数据一致性：多层补偿机制
🧪 测试步骤
查看初始状态：访问库存监控页面，确认Redis缓存为空
触发缓存：点击商品列表的"查看"按钮
测试购买流程：
立即支付 → 验证库存扣减
稍后支付 → 验证库存锁定
取消订单 → 验证库存回滚
观察定时任务：查看控制台日志中的补偿任务执行情况

RabbitMQ管理界面：
访问：http://localhost:15672
使用 admin/admin123 登录
应该能看到RabbitMQ管理控制台
MQ监控页面：
访问：http://localhost:8080/monitor/mq-status
查看MQ状态是否从"Mock模式"变为"RabbitMQ模式"
测试消息发送：
在MQ监控页面发送测试消息
在RabbitMQ管理界面查看队列和消息
🎯 预期结果
现在您应该看到：

✅ RabbitMQ管理界面可以正常访问
✅ MQ状态显示"RabbitMQ模式"
✅ 消息发送使用真实的RabbitMQ队列
✅ 在RabbitMQ管理界面可以看到队列创建和消息流转
创建订单 → 锁定库存 → 发送MQ消息
支付成功 → 扣减库存 → 发送MQ消息
订单取消 → 回滚库存 → 发送MQ消息